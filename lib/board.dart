import 'kittens_and_cats.dart';
import 'player.dart';
import 'general_functions.dart';

class Board {
  List<List> grid = List.filled(6, List.filled(6, null));
  late List<List> tempGrid = deepCopyMatrix(grid);
  int numberOfKittensToReturnIfMoveIsTakenBack = 0;
  int numberOfCatsToReturnIfMoveIsTakenBack = 0;
  // these are the coordinates that are on the grid
  List<int> validCoordinates = [0, 1, 2, 3, 4, 5];

  void prepareForPlacement(Player player) {
    for (int counter = 0; counter < numberOfKittensToReturnIfMoveIsTakenBack; counter++) {
      player.kittens.removeAt(0);
    }
    for (int counter = 0; counter < numberOfCatsToReturnIfMoveIsTakenBack; counter++) {
      player.cats.removeAt(0);
    }

    numberOfCatsToReturnIfMoveIsTakenBack = 0;
    numberOfKittensToReturnIfMoveIsTakenBack = 0;

    tempGrid = deepCopyMatrix(grid);
  }

  void boopCat(int row, int column, Player player) {
    prepareForPlacement(player);

    // return if the piece isn't placed on an open spot
    if (grid[row][column] != null) {
      return;
    }

    for (int i = -1; i < 2; i++) {
      for (int j = -1; j < 2; j++) {
        if (!validCoordinates.contains(row + i) || !validCoordinates.contains(column + j)) {
          continue;
        }
        boopCatInGivenDirection(row, column, i, j, player);
      }
    }

    grid[row][column] = Cat(player);
  }

  void boopKitten(int row, int column, Player player) {
    prepareForPlacement(player);

    // return if the piece isn't placed on an open spot
    if (grid[row][column] != null) {
      return;
    }

    for (int i = -1; i < 2; i++) {
      for (int j = -1; j < 2; j++) {
        if (!validCoordinates.contains(row + i) || !validCoordinates.contains(column + j)) {
          continue;
        }
        boopKittenInGivenDirection(row, column, i, j, player);
      }
    }

    grid[row][column] = Cat(player);
  }

  void boopCatInGivenDirection(int row, int column, int i, int j, Player player) {
    // ignore the coordinates that are not on the grid

    // if there is a piece neighboring the piece, "boop" it away
    if (grid[row + i][column + j] != null) {
      // if the piece is being moved off the edge, give it back to its owner
      if (!validCoordinates.contains(row + i + i) || !validCoordinates.contains(column + j + j)) {
        if (grid[row + i][column + j] is Kitten) {
          player.kittens.add(Kitten(player));
          numberOfKittensToReturnIfMoveIsTakenBack++;
        } else {
          player.cats.add(Cat(player));
          numberOfCatsToReturnIfMoveIsTakenBack++;
        }

        tempGrid[row + i][column + j] = null;
      }
      // unless the position it is being moved into isn't empty
      if (grid[row + i + i][column + j + j] != null) {
        return;
      } // if the piece can be "booped" into an empty space, "boop" it
      else {
        if (grid[row + i][column + j] is Kitten) {
          tempGrid[row + i + i][column + j + j] = Kitten(player);
        } else {
          tempGrid[row + i + i][column + j + j] = Cat(player);
        }

        tempGrid[row + i][column + j] = null;
      }
    }
  }

  void boopKittenInGivenDirection(int row, int column, int i, int j, Player player) {
    // ignore the coordinates that are not on the grid

    // if there is a kitten neighboring the piece, "boop" it away
    if (grid[row + i][column + j] is Kitten) {
      // if the kitten is being moved off the edge, give it back to its owner
      if (!validCoordinates.contains(row + i + i) || !validCoordinates.contains(column + j + j)) {
        player.kittens.add(Kitten(player));
        numberOfKittensToReturnIfMoveIsTakenBack++;

        tempGrid[row + i][column + j] = null;
      }
      // unless the position it is being moved into isn't empty
      if (grid[row + i + i][column + j + j] != null) {
        return;
      } // if the piece can be "booped" into an empty space, "boop" it
      else {
        tempGrid[row + i + i][column + j + j] = Kitten(player);
        tempGrid[row + i][column + j] = null;
      }
    }
  }

  void updateGrid() {
    grid = deepCopyMatrix(tempGrid);
  }

  List<List<List<int>>> findAllThreeInARow() {
    List<List<List<int>>> allCoordinates = [];

    // WARNING: WARNING: This code was generated by ChatGPT and could easily have some errors although the code looks pretty good

    // Check rows
    for (int row = 0; row < 6; row++) {
      for (int col = 0; col < 4; col++) {
        if (tempGrid[row][col] != null &&
            tempGrid[row][col] == tempGrid[row][col + 1] &&
            tempGrid[row][col] == tempGrid[row][col + 2]) {
          List<List<int>> coordinates = [];
          for (int i = 0; i < 3; i++) {
            coordinates.add([row, col + i]);
          }
          allCoordinates.add(coordinates);
        }
      }
    }

    // Check columns
    for (int col = 0; col < 6; col++) {
      for (int row = 0; row < 4; row++) {
        if (tempGrid[row][col] != null &&
            tempGrid[row][col] == tempGrid[row + 1][col] &&
            tempGrid[row][col] == tempGrid[row + 2][col]) {
          List<List<int>> coordinates = [];
          for (int i = 0; i < 3; i++) {
            coordinates.add([row + i, col]);
          }
          allCoordinates.add(coordinates);
        }
      }
    }

    // Check diagonals (top-left to bottom-right)
    for (int row = 0; row < 4; row++) {
      for (int col = 0; col < 4; col++) {
        if (tempGrid[row][col] != null &&
            tempGrid[row][col] == tempGrid[row + 1][col + 1] &&
            tempGrid[row][col] == tempGrid[row + 2][col + 2]) {
          List<List<int>> coordinates = [];
          for (int i = 0; i < 3; i++) {
            coordinates.add([row + i, col + i]);
          }
          allCoordinates.add(coordinates);
        }
      }
    }

    // Check diagonals (top-right to bottom-left)
    for (int row = 0; row < 4; row++) {
      for (int col = 2; col < 6; col++) {
        if (tempGrid[row][col] != null &&
            tempGrid[row][col] == tempGrid[row + 1][col - 1] &&
            tempGrid[row][col] == tempGrid[row + 2][col - 2]) {
          List<List<int>> coordinates = [];
          for (int i = 0; i < 3; i++) {
            coordinates.add([row + i, col - i]);
          }
          allCoordinates.add(coordinates);
        }
      }
    }

    return allCoordinates;
  }

  bool checkForWin(Player player) {
    int numberOfCatsInARow = 0;
    List<List<List<int>>> allThreeInARowCoordinates = findAllThreeInARow();
    for (List<List<int>> threeInARowCoordinates in allThreeInARowCoordinates) {
      for (List<int> coordinate in threeInARowCoordinates) {
        int row = coordinate[0];
        int column = coordinate[1];
        if (tempGrid[row][column] is Cat) {
          if (tempGrid[row][column].player == player) {
            numberOfCatsInARow++;
          }
        }
        if (numberOfCatsInARow == 3) {
          return true;
        }
      }
    }
    return false;
  }
}
